<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Memory Graph Viewer - Inference Lab</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/2.4.0/sigma.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/graphology/0.25.4/graphology.umd.min.js"></script>
    <style>
      * { box-sizing: border-box; }
      body {
        margin: 0;
        background: #0f172a;
        font-family: 'Segoe UI', system-ui, sans-serif;
        color: #e2e8f0;
        display: flex;
        height: 100vh;
        overflow: hidden;
      }

      /* Sidebar */
      #sidebar {
        width: 380px;
        background: #1e293b;
        border-right: 1px solid #334155;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      #sidebar-header {
        padding: 16px 20px;
        background: linear-gradient(135deg, #1e3a5f 0%, #1e293b 100%);
        border-bottom: 1px solid #334155;
      }

      #sidebar-header h1 {
        margin: 0;
        font-size: 18px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      #sidebar-header .badge {
        background: #22c55e;
        color: #052e16;
        font-size: 10px;
        padding: 2px 8px;
        border-radius: 10px;
        font-weight: 600;
      }

      .panel {
        border-bottom: 1px solid #334155;
      }

      .panel-header {
        padding: 12px 20px;
        background: #0f172a;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: #94a3b8;
      }

      .panel-header:hover {
        background: #1e293b;
      }

      .panel-content {
        padding: 16px 20px;
        max-height: 300px;
        overflow-y: auto;
      }

      /* Stats Panel */
      .stats-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }

      .stat-card {
        background: #0f172a;
        border: 1px solid #334155;
        border-radius: 8px;
        padding: 12px;
        text-align: center;
      }

      .stat-value {
        font-size: 24px;
        font-weight: 700;
        color: #38bdf8;
      }

      .stat-label {
        font-size: 11px;
        color: #64748b;
        margin-top: 4px;
      }

      /* Legend */
      .legend-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #cbd5e1;
      }

      .legend-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      /* Inference Lab */
      #inference-lab {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      #entity-select {
        width: 100%;
        padding: 10px 12px;
        background: #0f172a;
        border: 1px solid #334155;
        border-radius: 6px;
        color: #e2e8f0;
        font-size: 13px;
        margin-bottom: 12px;
      }

      #entity-select:focus {
        outline: none;
        border-color: #3b82f6;
      }

      .slider-group {
        margin-bottom: 16px;
      }

      .slider-group label {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #94a3b8;
        margin-bottom: 6px;
      }

      .slider-group input[type="range"] {
        width: 100%;
        -webkit-appearance: none;
        height: 6px;
        background: #334155;
        border-radius: 3px;
      }

      .slider-group input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        background: #3b82f6;
        border-radius: 50%;
        cursor: pointer;
      }

      #run-inference {
        width: 100%;
        padding: 12px;
        background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        transition: transform 0.1s, box-shadow 0.2s;
      }

      #run-inference:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
      }

      #run-inference:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      /* Inference Results */
      #inference-results {
        flex: 1;
        overflow-y: auto;
        padding: 16px 20px;
        background: #0f172a;
      }

      .result-empty {
        text-align: center;
        padding: 40px 20px;
        color: #64748b;
      }

      .result-empty .icon {
        font-size: 48px;
        margin-bottom: 12px;
      }

      .inference-card {
        background: #1e293b;
        border: 1px solid #334155;
        border-radius: 8px;
        padding: 14px;
        margin-bottom: 10px;
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }

      .inference-card .relation-type {
        display: inline-block;
        background: #7c3aed;
        color: white;
        padding: 2px 10px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 600;
        margin-bottom: 8px;
      }

      .inference-card .path {
        font-size: 13px;
        color: #e2e8f0;
        margin-bottom: 8px;
      }

      .inference-card .path .arrow {
        color: #64748b;
        margin: 0 6px;
      }

      .inference-card .path .entity {
        color: #38bdf8;
      }

      .inference-card .confidence {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }

      .confidence-bar {
        flex: 1;
        height: 6px;
        background: #334155;
        border-radius: 3px;
        overflow: hidden;
      }

      .confidence-fill {
        height: 100%;
        border-radius: 3px;
        transition: width 0.5s ease;
      }

      .confidence-value {
        color: #22c55e;
        font-weight: 600;
        min-width: 45px;
        text-align: right;
      }

      /* Graph Container */
      #graph-wrapper {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
      }

      #graph-toolbar {
        position: absolute;
        top: 16px;
        left: 16px;
        z-index: 100;
        display: flex;
        gap: 8px;
      }

      .toolbar-btn {
        background: rgba(30, 41, 59, 0.95);
        border: 1px solid #334155;
        color: #e2e8f0;
        padding: 8px 14px;
        border-radius: 6px;
        font-size: 13px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: background 0.2s;
      }

      .toolbar-btn:hover {
        background: #334155;
      }

      .toolbar-btn.active {
        background: #3b82f6;
        border-color: #3b82f6;
      }

      #container {
        flex: 1;
        background: #020617;
      }

      /* Tooltip */
      #tooltip {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(30, 41, 59, 0.98);
        border: 1px solid #475569;
        border-radius: 12px;
        padding: 20px;
        max-width: 400px;
        display: none;
        z-index: 1000;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      }

      #tooltip h3 {
        margin: 0 0 4px 0;
        color: #f1f5f9;
        font-size: 16px;
      }

      #tooltip .type {
        color: #64748b;
        font-size: 12px;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      #tooltip .type-badge {
        background: #334155;
        padding: 2px 8px;
        border-radius: 4px;
      }

      #tooltip ul {
        margin: 0;
        padding: 0;
        list-style: none;
        max-height: 200px;
        overflow-y: auto;
      }

      #tooltip li {
        padding: 6px 0;
        color: #94a3b8;
        font-size: 13px;
        border-bottom: 1px solid #334155;
      }

      #tooltip li:last-child {
        border-bottom: none;
      }

      /* Read-only indicator */
      #readonly-badge {
        position: absolute;
        top: 16px;
        right: 16px;
        background: rgba(239, 68, 68, 0.2);
        border: 1px solid rgba(239, 68, 68, 0.5);
        color: #fca5a5;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        z-index: 100;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      /* Scrollbar */
      ::-webkit-scrollbar {
        width: 6px;
      }

      ::-webkit-scrollbar-track {
        background: #1e293b;
      }

      ::-webkit-scrollbar-thumb {
        background: #475569;
        border-radius: 3px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: #64748b;
      }

      /* Loading spinner */
      .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid transparent;
        border-top-color: white;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      /* Inferred edge highlight */
      .inferred-highlight {
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
    </style>
  </head>
  <body>
    <!-- Sidebar -->
    <div id="sidebar">
      <div id="sidebar-header">
        <h1>üß† Memory Graph <span class="badge">READ ONLY</span></h1>
      </div>

      <!-- Stats Panel -->
      <div class="panel">
        <div class="panel-header">
          üìä Statistics
          <span>‚ñº</span>
        </div>
        <div class="panel-content">
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value" id="stat-entities">-</div>
              <div class="stat-label">Entities</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="stat-relations">-</div>
              <div class="stat-label">Relations</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="stat-types">-</div>
              <div class="stat-label">Entity Types</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="stat-observations">-</div>
              <div class="stat-label">Observations</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Legend Panel -->
      <div class="panel">
        <div class="panel-header">
          üé® Legend
          <span>‚ñº</span>
        </div>
        <div class="panel-content">
          <div class="legend-grid" id="legend-grid">
            <!-- Filled dynamically -->
          </div>
        </div>
      </div>

      <!-- Inference Lab -->
      <div class="panel" id="inference-lab">
        <div class="panel-header">
          üî¨ Inference Lab
          <span>‚ñº</span>
        </div>
        <div class="panel-content">
          <select id="entity-select">
            <option value="">Select an entity...</option>
          </select>

          <div class="slider-group">
            <label>
              <span>Max Depth</span>
              <span id="depth-value">3</span>
            </label>
            <input type="range" id="max-depth" min="1" max="5" value="3" />
          </div>

          <div class="slider-group">
            <label>
              <span>Min Confidence</span>
              <span id="confidence-value">0.5</span>
            </label>
            <input type="range" id="min-confidence" min="0" max="100" value="50" />
          </div>

          <button id="run-inference" disabled>
            <span>üß™</span>
            <span>Run Inference</span>
          </button>
        </div>
      </div>

      <!-- Inference Results -->
      <div id="inference-results">
        <div class="result-empty">
          <div class="icon">üîç</div>
          <div>Select an entity and run inference<br>to discover hidden relations</div>
        </div>
      </div>
    </div>

    <!-- Graph Container -->
    <div id="graph-wrapper">
      <div id="graph-toolbar">
        <button class="toolbar-btn" id="btn-zoom-in">üîç+ Zoom In</button>
        <button class="toolbar-btn" id="btn-zoom-out">üîç- Zoom Out</button>
        <button class="toolbar-btn" id="btn-reset">‚Ü∫ Reset</button>
        <button class="toolbar-btn" id="btn-hide-obs">üëÅ Hide Observations</button>
      </div>

      <div id="readonly-badge">
        üîí Read-Only Mode
      </div>

      <div id="container"></div>
    </div>

    <!-- Tooltip -->
    <div id="tooltip">
      <h3 id="tooltip-title"></h3>
      <div id="tooltip-type" class="type"></div>
      <ul id="tooltip-observations"></ul>
    </div>

    <script>
      // Global state
      let globalGraph = null;
      let globalRenderer = null;
      let globalData = { entities: [], relations: [] };
      let showObservations = true;
      let inferredEdges = [];

      // Color palette
      const typeColors = {
        "Project": "#facc15",
        "Person": "#4ade80",
        "Developer": "#4ade80",
        "Task": "#f87171",
        "Decision": "#a78bfa",
        "Technology": "#22d3ee",
        "Component": "#fb923c",
        "Feature": "#34d399",
        "Milestone": "#f472b6",
        "Requirement": "#60a5fa",
        "Risk": "#ef4444",
        "Bug": "#dc2626",
        "Research": "#fbbf24",
        "Insight": "#c084fc",
        "Convention": "#2dd4bf",
        "Proposal": "#fb7185",
        "Module": "#818cf8",
        "EntityType": "#64748b",
        "Lesson": "#fcd34d"
      };

      function colorByType(type) {
        return typeColors[type] || "#94a3b8";
      }

      // Load JSONL
      async function loadJSONL(url) {
        const res = await fetch(url);
        const text = await res.text();
        return text.split('\n').filter(l => l.trim()).map(l => JSON.parse(l));
      }

      // Build graph
      function buildGraph(data, includeObservations = true) {
        const graph = new graphology.Graph();
        const entityTypes = new Set();

        const entities = data.filter(item => item.entityType);
        const relations = data.filter(item => item.relationType);

        globalData.entities = entities;
        globalData.relations = relations;

        entities.forEach(e => entityTypes.add(e.entityType));

        // Type hub nodes
        let typeIndex = 0;
        entityTypes.forEach(type => {
          const angle = (2 * Math.PI * typeIndex) / entityTypes.size;
          graph.addNode(`type:${type}`, {
            label: type,
            x: Math.cos(angle) * 4,
            y: Math.sin(angle) * 4,
            size: 30,
            color: colorByType(type),
            nodeType: 'entityType'
          });
          typeIndex++;
        });

        // Entity nodes
        const entitiesPerType = {};
        entities.forEach(e => {
          if (!entitiesPerType[e.entityType]) entitiesPerType[e.entityType] = [];
          entitiesPerType[e.entityType].push(e);
        });

        Object.entries(entitiesPerType).forEach(([type, typeEntities]) => {
          typeEntities.forEach((e, idx) => {
            const nodeId = `entity:${e.name}`;
            const typeNode = `type:${type}`;
            const typeAttrs = graph.getNodeAttributes(typeNode);

            const count = typeEntities.length;
            const angle = (2 * Math.PI * idx) / count;
            const radius = 0.8 + (count > 10 ? count * 0.1 : count * 0.15);

            graph.addNode(nodeId, {
              label: e.name.length > 30 ? e.name.substring(0, 30) + '...' : e.name,
              fullName: e.name,
              x: typeAttrs.x + Math.cos(angle) * radius,
              y: typeAttrs.y + Math.sin(angle) * radius,
              size: 12,
              color: colorByType(type),
              nodeType: 'entity',
              entityType: type,
              observations: e.observations || []
            });

            graph.addEdge(nodeId, typeNode, { size: 1, color: "#334155", edgeType: 'type' });

            // Observation nodes
            if (includeObservations && e.observations) {
              e.observations.slice(0, 5).forEach((obs, obsIdx) => {
                const obsId = `obs:${e.name}:${obsIdx}`;
                const obsAngle = (2 * Math.PI * obsIdx) / Math.min(e.observations.length, 5);
                const obsOffset = 0.4;

                const entityAttrs = graph.getNodeAttributes(nodeId);
                graph.addNode(obsId, {
                  label: obs.length > 20 ? obs.substring(0, 20) + '...' : obs,
                  x: entityAttrs.x + Math.cos(obsAngle) * obsOffset,
                  y: entityAttrs.y + Math.sin(obsAngle) * obsOffset,
                  size: 5,
                  color: "#475569",
                  nodeType: 'observation',
                  fullText: obs
                });

                graph.addEdge(nodeId, obsId, { size: 0.5, color: "#1e293b", edgeType: 'observation' });
              });
            }
          });
        });

        // Relation edges
        relations.forEach(rel => {
          const fromNode = `entity:${rel.from}`;
          const toNode = `entity:${rel.to}`;

          if (graph.hasNode(fromNode) && graph.hasNode(toNode)) {
            const edgeKey = `${fromNode}->${toNode}`;
            if (!graph.hasEdge(edgeKey)) {
              graph.addEdgeWithKey(edgeKey, fromNode, toNode, {
                size: 2,
                color: "#f59e0b",
                label: rel.relationType,
                edgeType: 'relation'
              });
            }
          }
        });

        return { graph, stats: { entities: entities.length, relations: relations.length, types: entityTypes.size, observations: entities.reduce((sum, e) => sum + (e.observations?.length || 0), 0) } };
      }

      // Update stats UI
      function updateStats(stats) {
        document.getElementById('stat-entities').textContent = stats.entities;
        document.getElementById('stat-relations').textContent = stats.relations;
        document.getElementById('stat-types').textContent = stats.types;
        document.getElementById('stat-observations').textContent = stats.observations;
      }

      // Build legend
      function buildLegend() {
        const legendGrid = document.getElementById('legend-grid');
        legendGrid.innerHTML = '';

        const types = [...new Set(globalData.entities.map(e => e.entityType))];
        types.forEach(type => {
          const item = document.createElement('div');
          item.className = 'legend-item';
          item.innerHTML = `<span class="legend-dot" style="background:${colorByType(type)}"></span>${type}`;
          legendGrid.appendChild(item);
        });

        // Add relation legend
        const relItem = document.createElement('div');
        relItem.className = 'legend-item';
        relItem.innerHTML = `<span class="legend-dot" style="background:#f59e0b"></span>Relation`;
        legendGrid.appendChild(relItem);

        const inferItem = document.createElement('div');
        inferItem.className = 'legend-item';
        inferItem.innerHTML = `<span class="legend-dot" style="background:#8b5cf6"></span>Inferred`;
        legendGrid.appendChild(inferItem);
      }

      // Populate entity select
      function populateEntitySelect() {
        const select = document.getElementById('entity-select');
        select.innerHTML = '<option value="">Select an entity...</option>';

        const groupedEntities = {};
        globalData.entities.forEach(e => {
          if (!groupedEntities[e.entityType]) groupedEntities[e.entityType] = [];
          groupedEntities[e.entityType].push(e.name);
        });

        Object.entries(groupedEntities).sort().forEach(([type, names]) => {
          const optgroup = document.createElement('optgroup');
          optgroup.label = type;
          names.sort().forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name.length > 40 ? name.substring(0, 40) + '...' : name;
            optgroup.appendChild(option);
          });
          select.appendChild(optgroup);
        });
      }

      // Run inference (simulated - in real app, would call MCP server)
      function runInference(entityName, maxDepth, minConfidence) {
        // Simulated inference based on graph traversal
        const results = [];
        const visited = new Set();
        const queue = [{ node: entityName, path: [entityName], depth: 0, confidence: 1.0 }];

        const relationConfidence = {
          'depends_on': 0.95,
          'implements': 0.90,
          'affects': 0.85,
          'part_of': 0.90,
          'owns': 0.80,
          'threatens': 0.75,
          'related_to': 0.60,
          'will_implement': 0.70,
          'proposes': 0.65,
          'caused_by': 0.85,
          'fixes': 0.90
        };

        while (queue.length > 0) {
          const { node, path, depth, confidence } = queue.shift();

          if (depth >= maxDepth) continue;

          // Find outgoing relations
          globalData.relations.forEach(rel => {
            if (rel.from === node && !visited.has(rel.to)) {
              const relConf = relationConfidence[rel.relationType] || 0.5;
              const newConf = confidence * relConf;

              if (newConf >= minConfidence && path.length > 1) {
                results.push({
                  from: entityName,
                  to: rel.to,
                  relationType: `transitively_${rel.relationType}`,
                  confidence: newConf,
                  path: [...path, `--[${rel.relationType}]-->`, rel.to],
                  depth: depth + 1
                });
              }

              visited.add(rel.to);
              queue.push({
                node: rel.to,
                path: [...path, `--[${rel.relationType}]-->`, rel.to],
                depth: depth + 1,
                confidence: newConf
              });
            }
          });
        }

        // Sort by confidence
        return results.sort((a, b) => b.confidence - a.confidence).slice(0, 20);
      }

      // Display inference results
      function displayResults(results) {
        const container = document.getElementById('inference-results');

        if (results.length === 0) {
          container.innerHTML = `
            <div class="result-empty">
              <div class="icon">ü§∑</div>
              <div>No inferred relations found<br>Try lowering min confidence or increasing depth</div>
            </div>
          `;
          return;
        }

        container.innerHTML = results.map((r, i) => {
          const confPercent = (r.confidence * 100).toFixed(1);
          const confColor = r.confidence > 0.8 ? '#22c55e' : r.confidence > 0.6 ? '#eab308' : '#f97316';

          return `
            <div class="inference-card" style="animation-delay: ${i * 50}ms">
              <span class="relation-type">${r.relationType}</span>
              <div class="path">
                ${r.path.map((p, idx) => {
                  if (p.startsWith('--[')) {
                    return `<span class="arrow">${p}</span>`;
                  }
                  return `<span class="entity">${p}</span>`;
                }).join('')}
              </div>
              <div class="confidence">
                <span>Confidence:</span>
                <div class="confidence-bar">
                  <div class="confidence-fill" style="width: ${confPercent}%; background: ${confColor}"></div>
                </div>
                <span class="confidence-value" style="color: ${confColor}">${confPercent}%</span>
              </div>
            </div>
          `;
        }).join('');

        // Highlight inferred edges on graph
        highlightInferredEdges(results);
      }

      // Highlight inferred edges
      function highlightInferredEdges(results) {
        // Remove old inferred edges
        inferredEdges.forEach(edgeKey => {
          if (globalGraph.hasEdge(edgeKey)) {
            globalGraph.dropEdge(edgeKey);
          }
        });
        inferredEdges = [];

        // Add new inferred edges
        results.forEach(r => {
          const fromNode = `entity:${r.from}`;
          const toNode = `entity:${r.to}`;

          if (globalGraph.hasNode(fromNode) && globalGraph.hasNode(toNode)) {
            const edgeKey = `inferred:${r.from}->${r.to}`;
            if (!globalGraph.hasEdge(edgeKey)) {
              globalGraph.addEdgeWithKey(edgeKey, fromNode, toNode, {
                size: 3,
                color: "#8b5cf6",
                label: r.relationType,
                edgeType: 'inferred'
              });
              inferredEdges.push(edgeKey);
            }
          }
        });

        globalRenderer.refresh();
      }

      // Main
      (async () => {
        const data = await loadJSONL("memory.jsonl");
        const { graph, stats } = buildGraph(data, showObservations);
        globalGraph = graph;

        updateStats(stats);
        buildLegend();
        populateEntitySelect();

        globalRenderer = new Sigma(graph, document.getElementById("container"), {
          renderEdgeLabels: false,
          labelDensity: 0.15,
          labelGridCellSize: 120,
          labelRenderedSizeThreshold: 8,
          defaultEdgeColor: '#475569',
          labelColor: { color: '#e5e7eb' },
          minCameraRatio: 0.1,
          maxCameraRatio: 10
        });

        // Tooltip
        const tooltip = document.getElementById('tooltip');
        const tooltipTitle = document.getElementById('tooltip-title');
        const tooltipType = document.getElementById('tooltip-type');
        const tooltipObs = document.getElementById('tooltip-observations');

        globalRenderer.on("enterNode", ({ node }) => {
          const attrs = graph.getNodeAttributes(node);
          tooltipTitle.textContent = attrs.fullName || attrs.label;
          tooltipType.innerHTML = `<span class="type-badge">${attrs.nodeType}</span> ${attrs.entityType || ''}`;
          tooltipObs.innerHTML = '';

          if (attrs.observations && attrs.observations.length > 0) {
            attrs.observations.forEach(obs => {
              const li = document.createElement('li');
              li.textContent = obs;
              tooltipObs.appendChild(li);
            });
          } else if (attrs.fullText) {
            const li = document.createElement('li');
            li.textContent = attrs.fullText;
            tooltipObs.appendChild(li);
          }

          tooltip.style.display = 'block';
        });

        globalRenderer.on("leaveNode", () => {
          tooltip.style.display = 'none';
        });

        // Click to select for inference
        globalRenderer.on("clickNode", ({ node }) => {
          const attrs = graph.getNodeAttributes(node);
          if (attrs.nodeType === 'entity') {
            document.getElementById('entity-select').value = attrs.fullName || attrs.label;
            document.getElementById('run-inference').disabled = false;
          }
        });

        // Toolbar buttons
        document.getElementById('btn-zoom-in').onclick = () => {
          const camera = globalRenderer.getCamera();
          camera.animatedZoom({ duration: 300 });
        };

        document.getElementById('btn-zoom-out').onclick = () => {
          const camera = globalRenderer.getCamera();
          camera.animatedUnzoom({ duration: 300 });
        };

        document.getElementById('btn-reset').onclick = () => {
          const camera = globalRenderer.getCamera();
          camera.animatedReset({ duration: 500 });
        };

        document.getElementById('btn-hide-obs').onclick = function() {
          showObservations = !showObservations;
          this.textContent = showObservations ? 'üëÅ Hide Observations' : 'üëÅ Show Observations';
          this.classList.toggle('active', !showObservations);

          // Rebuild graph
          const { graph: newGraph, stats } = buildGraph(data, showObservations);
          globalGraph = newGraph;
          globalRenderer.setGraph(newGraph);
          updateStats(stats);
        };

        // Inference controls
        const entitySelect = document.getElementById('entity-select');
        const maxDepthSlider = document.getElementById('max-depth');
        const minConfSlider = document.getElementById('min-confidence');
        const runBtn = document.getElementById('run-inference');

        entitySelect.onchange = () => {
          runBtn.disabled = !entitySelect.value;
        };

        maxDepthSlider.oninput = () => {
          document.getElementById('depth-value').textContent = maxDepthSlider.value;
        };

        minConfSlider.oninput = () => {
          document.getElementById('confidence-value').textContent = (minConfSlider.value / 100).toFixed(2);
        };

        runBtn.onclick = () => {
          const entity = entitySelect.value;
          const maxDepth = parseInt(maxDepthSlider.value);
          const minConf = minConfSlider.value / 100;

          runBtn.disabled = true;
          runBtn.innerHTML = '<span class="spinner"></span><span>Running...</span>';

          // Simulate async inference
          setTimeout(() => {
            const results = runInference(entity, maxDepth, minConf);
            displayResults(results);

            runBtn.disabled = false;
            runBtn.innerHTML = '<span>üß™</span><span>Run Inference</span>';
          }, 500);
        };
      })();
    </script>
  </body>
</html>